model state_neuron:
    parameters:
        kp real = 1 # Gain
        pos boolean = true # Sign sensitivity of the neuron
        base_rate Hz = 0 Hz # Base firing rate
        buffer_size ms = 150.0 ms # Size of the sliding window
        buffer_size_error ms = 25.0 ms
        simulation_steps integer = 1000 # Number of simulation steps (simulation_time/resolution())
        N_fbk integer = 200 # Population size for sensory feedback
        N_pred integer = 200 # Population size for sensory prediction
        N_error integer = 200
        C_error real = 5.0 
        fbk_bf_size integer = 30000
        pred_bf_size integer = 30000
        error_bf_size integer = 25
        time_wait ms = 150.0 ms
        time_trial ms = 650.0 ms

    state:
        in_rate Hz = 0 Hz # Input firing rate: to be computed from spikes
        out_rate Hz = 0 Hz # Output firing rate: defined accordingly to the input firing rate
        spike_count_out integer = 0 # Outgoing spikes

        current_fbk_input[N_fbk] real = 0
        current_pred_input[N_pred] real = 0

        fbk_buffer[fbk_bf_size] real = 0 # Buffer for sensory feedback spikes
        pred_buffer[pred_bf_size] real = 0 # Buffer for sensory prediction spikes

        fbk_counts[N_fbk] real = 0 # Counts of incoming feedback spikes
        pred_counts[N_pred] real = 0 # Counts of incoming prediction spikes

        tick integer = 0 # Tick 
        position_count integer = 0 
        mean_fbk real = 0.0 # Mean sensory feedback
        mean_pred real = 0.0 # Mean sensory prediction

        var_fbk real = 0.0 # Variance of sensory feedback
        var_pred real = 0.0 # Variance of sensory prediction

        CV_fbk real = 0.0 # Coefficient of variation of sensory feedback
        CV_pred real = 0.0 # Coefficient of variation of sensory prediction

        #################
        current_error_input real = 0
        error_buffer[error_bf_size] real = 0
        err_pos_count integer = 0 

        error_counts real = 0.0

        error_rate real = 0.0
        fbk_rate real = 0.0

        w_fbk real = 0.0
        w_pred real = 0.0

        #################

        total_CV real = 0.0
        
        lambda_poisson real = 0 # Parameter of the Poisson distribution defining generator behavior
    
    internals:
        res ms = resolution()
        buffer_steps integer = steps(buffer_size)
        trial_steps integer = steps(time_trial)
        wait_steps integer = steps(time_wait)
        buffer_error_steps integer = steps(buffer_size_error)
          
    input: 
        fbk_spikes[N_fbk] <- spike
        pred_spikes[N_pred] <- spike
        error_spikes <- spike        
    
    output:
        spike
        
    update:
        tick = steps(t)

        # Save incoming spikes in the two buffers
        i integer = 0

        # in input port I have probability instead of count... don't know why
        current_error_input= error_spikes / (resolution() * 0.001)
        
        for i in 0 ... (N_fbk-1) step 1:
            current_fbk_input[i] = fbk_spikes[i]

        j integer = 0
        
        for j in 0 ... (N_pred-1) step 1:
            current_pred_input[j] = pred_spikes[j]
        
        index integer = 0
        for i in 0 ... (N_fbk-1) step 1:
            index = position_count * N_fbk + i
            fbk_buffer[index] = current_fbk_input[i]
        
        for j in 0 ... (N_pred-1) step 1:
            index = position_count*N_pred + j
            pred_buffer[index] = current_pred_input[j]
        
        # Update position count
        position_count+=1
        if position_count > buffer_steps-1:
            position_count = 0
        
        # Populate count_spikes
        k integer = 0 # Index for bfk_counts
        jump integer = 0 
        for k in 0 ... (N_fbk-1) step 1:
            fbk_counts[k] = 0 # Clean previous value
            for jump in 0 ... (buffer_steps-1) step 1:
                index = N_fbk * jump + k
                if fbk_buffer[index] != 0:
                    fbk_counts[k] += 1
        
        m integer = 0
        for m in 0 ... (N_pred-1) step 1:
            pred_counts[m] = 0
            for jump in 0 ... (buffer_steps-1) step 1:
                index = (N_pred * jump) + m
                if pred_buffer[index] != 0:
                    pred_counts[m] += 1
        
        # Compute mean and variability of both buffers
        mean_fbk = 0.0
        if N_fbk == 0:
            CV_fbk = 10**6
        else:
            for k in 0 ... (N_fbk-1) step 1:
                mean_fbk += fbk_counts[k]
            mean_fbk /= N_fbk

        mean_pred = 0.0
        if N_pred == 0:
            CV_pred = 10**6
        else:
            for m in 0 ... (N_pred-1) step 1:
                mean_pred += pred_counts[m]
            mean_pred /= N_pred


        ####################################
        error_buffer[err_pos_count] = current_error_input

        err_pos_count += 1
        if err_pos_count > buffer_error_steps-1:
            err_pos_count = 0
        
        error_counts = 0.0
        e_idx integer = 0
        for e_idx in 0 ... (buffer_error_steps-1) step 1:
            if error_buffer[e_idx] != 0:
                error_counts += error_buffer[e_idx]
        
        if error_counts != 0:
            error_rate = (1000 * error_counts) / (buffer_error_steps * N_error)
            fbk_rate = (1000 * mean_fbk) / buffer_steps
            
            w_fbk = abs(error_rate) / max(max(abs(error_rate), abs(fbk_rate)), C_error)
            w_pred = 1 - w_fbk
        else:
            w_fbk = 1
            w_pred = 0

        ####################################

        in_rate = (mean_pred*w_pred + mean_fbk*w_fbk)/buffer_size

        out_rate = base_rate + kp * in_rate

        lambda_poisson = out_rate * resolution() * 0.001

        #spike_count_out = random_poisson(lambda_poisson)

        # Now draw randomly according to probability distribution        
        spike_count_out = random_poisson(lambda_poisson)

        if spike_count_out > 0 and (tick % trial_steps) > wait_steps:
            emit_spike()
